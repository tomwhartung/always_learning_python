
# 4-polls_to_emails project

Experimenting with parts of djangoproject.com's polls app, attempting to apply the steps to a simple app that stores emails.

## References:

Most of this is based on information on this page:

(1) https://docs.djangoproject.com/en/1.10/intro/tutorial01/

If I need a second opinion, I will probably go to the O'Reilly book, Lightweight Django:

(2) http://shop.oreilly.com/product/0636920032502.do

However, I am learning that the djangoproject site seems to really be the best source of information.

## Goal:

Following the steps in the tutorial for the polls app, we want to try making an app that stores emails in a database.

1. Initially we want to gather the email addresses of people who visit a site and are interested in more information.

2. There will not be any sort of online access to these; if and when we use them it will be from behind a firewall.

3. If and when we do use them, we will want to provide an interface for unsubscribing from the list.

## Requirements:

For this application, we will use SQLite.

Based on what I read in the book today, django provides default forms for entering data.

It is perfectly acceptable to use these default forms rather than create our own.

### Values to Store

We need only one table to store the following information:

* Subscriber's Name - optional string; prompt for both first and last name
* Subscriber's Email - required string; plan to validate in both front and back end (at least require an "@" and a ".")
* Site (List Name) - required 2-character site abbreviation: 'g' 'jm' 'sm' 'th' 'tw'; hidden value in email submission form
* Subscription Date - timestamp; populated automatically

## Initial setup

### The `documents` Directory

Decided to create this and put a simple "Hello world" index.html file in it.

This may come in handy some day - possibly for sharing static content between apps - especially if I already have it.

### The `Site` Directory

This directory contains the code we are writing, based on the polls app but modified for our simple email gathering app.

## Tutorial (1) - Project and App Setup

Taking note of the commands run to set this up, so we can do it more quickly when it's time to do it "for realsies."

### Step (1.1) Starting with startproject:

Note that we need to run the `python3` command to run the server, so that it can access django.

```
django-admin startproject Site
git add Site
git commit -m 'Files generated by "django-admin startproject Site" command.'
git push origin master
cd Site
python3 manage.py runserver
```

Accessing the following URL should display the "It worked!" message.

* http://localhost:8000/

### Step (1.2) Running startapp:

From Part 1 of the tutorial at djangoproject.com:

* "A project is a collection of configuration and apps for a particular website. A project can contain multiple apps. An app can be in multiple projects."

```
django-admin startapp get_emails
git add get_emails
git commit -m 'Files generated by "django-admin startapp get_emails" command.'
git push origin master
```

### Step (1.3) creating a view:

Note that we need to run the `python3` command to run the server, so that it can access django.

```
cd get_emails
vi views.py   ## Updated as described in the main reference (1)
vi urls.py    ## Updated as described in the main reference (1)
cd ../Site
vi urls.py    ## Updated as described in the main reference (1)
python3 manage.py runserver
```

Accessing the following URL displays the "Hi from the get_emails index." message.

* http://localhost:8000/get_emails/

(Commit changes to github.)

## Tutorial (2) - Database Setup

As mentioned in the Requirements section, we are using SQLite and creating only one table, which in turn has only a few columns.

Reference: https://docs.djangoproject.com/en/1.10/intro/tutorial02/

> SQLite is included in Python, so you won’t need to install anything else to support your database.

### Step (2.1) Edit the Settings

Following the reference, edit the values for the TIME_ZONE and INSTALLED_APPS parameters in `settings.py` and run `migrate` .

```
vi Site/settings.py           ## The list of default apps looks reasonable to me (changed the TIME_ZONE only)
python3 manage.py migrate     ## Note: use python3!!
git add settings.py
git commit -m 'Updated the TIME_ZONE in settings.py (the list of INSTALLED_APPS looks reasonable enough to me).'
git add db.sqlite3
git commit -m 'Version of db.sqlite3 updated by running migrate.'
```

We can now run the `python3 manage.py runserver` command without it complaining about needing to run the migrations.

### Step (2.2) Create the Models

Creating only one table: SubscriberEmail

> The name of each Field instance (e.g. question_text or pub_date) is the field’s name, in machine-friendly format. You’ll use this value in your Python code, and your database will use it as the column name.

```
vi get_emails/models.py
cat get_emails/models.py
...
class SubscriberEmail( models.Model ) :
   name = models.CharField( max_length=45 )
   email = models.CharField( max_length=254 )
   site_code = models.CharField( max_length=2 )
   subscription_date = models.DateTimeField('date subscribed')
...
```

### Step (2.3) Activating the Models

Edit the settings and run makemigrations:

```
vi Site/settings.py              ## Add get_emails.apps.GetEmailsConfig to INSTALLED_APPS
python3 manage.py makemigrations get_emails
```

The output from that command looks good:

```
Migrations for 'get_emails':
  get_emails/migrations/0001_initial.py:
    - Create model SubscriberEmail
```

> The sqlmigrate command takes migration names and returns their SQL:

```
python3 manage.py sqlmigrate get_emails 0001
```

The output from that command also looks good:

```
BEGIN;
--
-- Create model SubscriberEmail
--
CREATE TABLE "get_emails_subscriberemail"
   ( "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT,
     "name" varchar(45) NOT NULL,
     "email" varchar(254) NOT NULL,
     "site_code" varchar(2) NOT NULL,
     "subscription_date" datetime NOT NULL );
COMMIT;
```

> The sqlmigrate command ... is ... useful for checking what Django is going to do ....

> ... you can also run `python manage.py check` ... without making migrations or touching the database.

Run migrate to create the table in the database:

```
python3 manage.py migrate
```

The output from that command also looks good:

```
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, get_emails, sessions
Running migrations:
  Applying get_emails.0001_initial... OK
```

### Process Summary and Other Options

Following is the process for making migrations (changes to the database):

1. Update get_emails/models.py with desired changes
2. Run `python3 manage.py makemigrations` to create the migrations
3. Run `python3 manage.py migrate` to apply the migrations

For full documentation see:

* https://docs.djangoproject.com/en/1.10/topics/migrations/

Other options (in addition to `makemigrations` and `migrate`):

* `python3 manage.py showmigrations` - "shows all the migrations for a project"
* `python3 manage.py sqlmigrate` - show the sql for a migration
* `python3 manage.py check` = "Uses the system check framework to inspect the entire Django project for common problems"

There are more (including `startproject` and `startapp` and `shell`)!

* https://docs.djangoproject.com/en/1.10/ref/django-admin/

### Step (2.5) Exploring the API

In a python3 shell, run a few simple commands to test the functionality:

```
 $ python3 manage.py shell
Python 3.5.2 (default, Sep 10 2016, 08:21:44)
[GCC 5.4.0 20160609] on linux
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
>>> from get_emails.models import SubscriberEmail
>>> SubscriberEmail.objects.all()
<QuerySet []>
>>> from django.utils import timezone
>>> semail = SubscriberEmail( name='Zeronimo', email='kitty@cat.com', site_code='th', subscription_date=timezone.now())
>>> semail.save()
>>> semail.id
1
>>> semail.name
'Zeronimo'
>>> semail.email
'kitty@cat.com'
>>> semail.site_code
'th'
>>> semail.subscription_date
datetime.datetime(2016, 10, 18, 2, 46, 44, 577331, tzinfo=<UTC>)
>>> semail.email = 'zeronimo@tomhartung.com'
>>> semail.email
'zeronimo@tomhartung.com'
>>>
```

It works as it should!

#### More fun with the API

Refining our model, setting default values, etc. and testing the changes....

Some common commands, presented without the prompts and with output as comments:

```
###
### Setup - we always want to run these commands:
###
python3 manage.py shell
from get_emails.models import SubscriberEmail
###
### Getting data:
###
SubscriberEmail.objects.all()
# <QuerySet [<SubscriberEmail: kitty@cat.com (Zeronimo) th>, <SubscriberEmail: mildred@cats.com (mildred) gr>, <SubscriberEmail: marvin@imissyou.com (marvin) uk>]>
SubscriberEmail.objects.filter(id=3)
# <QuerySet [<SubscriberEmail: marvin@imissyou.com (marvin) uk>]>
###
### Creating, changing, and storing new objects - don't forget to call .save() :
###
from django.utils import timezone
marvin = SubscriberEmail( name='marvin', email='marvin@imissyou.com', subscription_date=timezone.now() )
marvin = SubscriberEmail.objects.get( pk=3 )
marvin.name = "Starvin' Marvin"
SubscriberEmail.objects.filter( id=3 )
###
### Testing defaults - *before* adding them to models.py:
###
neonoir = SubscriberEmail( email='neonoir@imissyou.com' )
neonoir.save()      ## Before adding defaults get: 'sqlite3.IntegrityError: NOT NULL constraint failed: ...'
###
### Testing defaults - *after* adding them to models.py:
###   name - '' (blank)
###   site_code - 'xx' (for 'Unknown')
###   subscription_date - timestamp.now()
### Note:
###   must exit and re-enter the python3 shell to load the new version of models.py
###
exit()
python3 manage.py shell
from get_emails.models import SubscriberEmail
neonoir = SubscriberEmail( email='neonoir@imissyou.com' )
neonoir.save()     ## After adding defaults, this works OK
```

For a good time, see the two versions getSiteName in models.py:

```
site_name = SubscriberEmail.getSiteNameSingleArg( site_code )
site_name = self.getSiteNameSelfVersion( site_code )
```

The code has plenty of comments which I will not duplicate here.

#### Data cleanup/play time

Back to showing the '>>>' prompts and all output as-is:

```
>>> neonoir = SubscriberEmail.objects.get( pk=4 )
>>> print( neonoir )
neonoir@imissyou.com site_unknown
>>> neonoir.name = 'Neo Noir'
>>> neonoir.site_code = 'sm'
>>> print( neonoir )
neonoir@imissyou.com (Neo Noir) seeourminds.com
>>> neonoir.save()
>>> SubscriberEmail.objects.all( )
<QuerySet [<SubscriberEmail: kitty@cat.com (Zeronimo) tomhartung.com>, <SubscriberEmail: mildred@cats.com (mildred) groja.com>, <SubscriberEmail: marvin@imissyou.com (Starvin' Marvin) site_unknown>, <SubscriberEmail: neonoir@imissyou.com (Neo Noir) seeourminds.com>]>
>>> SubscriberEmail.objects.get( pk=4 )
<SubscriberEmail: neonoir@imissyou.com (Neo Noir) seeourminds.com>
>>> mildred = SubscriberEmail.objects.get( pk=2 )
>>> mildred.name = "Mildred Memah Myrnamyrn"
>>> SubscriberEmail.objects.get( pk=2 )
<SubscriberEmail: mildred@cats.com (mildred) groja.com>
>>> mildred.save
<bound method Model.save of <SubscriberEmail: mildred@cats.com (Mildred Memah Myrnamyrn) groja.com>>
>>> mildred.save()
>>> SubscriberEmail.objects.get( pk=2 )
<SubscriberEmail: mildred@cats.com (Mildred Memah Myrnamyrn) groja.com>
>>> marvin = SubscriberEmail.objects.get( pk=3 )
>>> marvin.site_code = 'tw'
>>> SubscriberEmail.objects.get( pk=3 )
<SubscriberEmail: marvin@imissyou.com (Starvin' Marvin) site_unknown>
>>> marvin.save()
>>> SubscriberEmail.objects.get( pk=3 )
<SubscriberEmail: marvin@imissyou.com (Starvin' Marvin) tomwhartung.com>
>>>

```

#### Adding a column

Decided to add a `subscribed` column (BooleanField).

Note: After adding it, it did not tell me I had to makemigrations or anything, but complained about the use of "true" .

```
vi get_emails/models.py            ## Add BooleanField "subscribed"
python3 manage.py shell            ## No complaints (I expected some!)
python3 manage.py makemigrations   ## Created 0002_auto_20161018_1441.py
### System check identified some issues:
###
### WARNINGS:
### get_emails.SubscriberEmail.subscription_date: (fields.W161) Fixed default value provided.
###         HINT: It seems you set a fixed date / time / datetime value as default for this field. This may not be what you want. If you want to have the current date as default, use `django.utils.timezone.now`
### Migrations for 'get_emails':
###   get_emails/migrations/0002_auto_20161018_1441.py:
###     - Add field subscribed to subscriberemail
###     - Alter field name on subscriberemail
###     - Alter field site_code on subscriberemail
###     - Alter field subscription_date on subscriberemail
vi get_emails/models.py             ## Changed `django.utils.timezone.now()` to `django.utils.timezone.now`
python3 manage.py makemigrations    ## Created 0003_auto_20161018_1442.py
### Migrations for 'get_emails':
###   get_emails/migrations/0003_auto_20161018_1442.py:
###     - Alter field subscription_date on subscriberemail
```

We did not apply the migrations, but `check` did not notice that.

Actually trying to access one of our subscriber email records, though, caused an error.

```
python3 manage.py check
### System check identified no issues (0 silenced).
python3 manage.py shell
Python 3.5.2 (default, Sep 10 2016, 08:21:44)
[GCC 5.4.0 20160609] on linux
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
>>> from get_emails.models import SubscriberEmail
>>> SubscriberEmail.objects.get( pk=1 )
Traceback (most recent call last):
  File "/usr/local/lib/python3.5/dist-packages/django/db/backends/utils.py", line 64, in execute
    return self.cursor.execute(sql, params)
  File "/usr/local/lib/python3.5/dist-packages/django/db/backends/sqlite3/base.py", line 337, in execute
    return Database.Cursor.execute(self, query, params)
sqlite3.OperationalError: no such column: get_emails_subscriberemail.subscribed
>>> exit(0)
```

It was easy enough to fix, just wondering if and when it would complain.

```
python3 manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, get_emails, sessions
Running migrations:
  Applying get_emails.0002_auto_20161018_1441... OK
  Applying get_emails.0003_auto_20161018_1442... OK
tomh@barbara: /var/www/learn/django/github/customizations/always_learning_python/4-polls_to_emails/Site
 $ python3 manage.py shell
Python 3.5.2 (default, Sep 10 2016, 08:21:44)
[GCC 5.4.0 20160609] on linux
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
>>> from get_emails.models import SubscriberEmail
>>> SubscriberEmail.objects.get( pk=1 )
<SubscriberEmail:
	#1: zeronimouser@cats.com (Zeronimo the Zeronimonster!) tomhartung.com (th) 2016-10-18 02:46:44.577331+00:00
>
>>> exit(0)
```

References:

* https://docs.djangoproject.com/en/1.10/topics/db/queries/
* https://docs.djangoproject.com/en/1.10/ref/models/fields/#choices
* https://docs.djangoproject.com/en/1.10/ref/models/fields/#booleanfield

#### Exploring the Admin Interface

Reference: https://docs.djangoproject.com/en/1.10/intro/tutorial02/#introducing-the-django-admin

```
python3 manage.py createsuperuser   ## play/email@example.com/password
```

Access in browser:

* http://127.0.0.1:8000/admin/

Add the following lines to get_emails/admin.py :

```
from .models import SubscriberEmail
admin.site.register( SubscriberEmail )
```

Reload browser for GUI CRUD access!

## Tutorial (3) - Views

Reference: https://docs.djangoproject.com/en/1.10/intro/tutorial03/

### Requirements

The goal is just one simple view containing a form.

Each site will have a widget with a two-element form (text box and button) in which the visitor can enter their email address.

Submitting the form takes them to this view.

NOTE: the next Tutorial (4) covers forms.

### Step (3.1) Writing More Views

Add a "get_emails/subscribe" route to `urls.py` and corresponding view function to `views.py` .

```
vi urls.py     ## Add "get_emails/subscribe" route 
vi views.py    ## Add minimal "subscribe" function
```

It's always nice when the "hello world" part is a no-brainer - which it is for me, at this point.  Amazing!

### Step (3.2) Write views that actually do something

We could do something similar to what the tutorial does and display the last few email addresses added,
but we would have to mask them for security reasons, and that is ultimately of very limited value.

#### Update index to display count of emails

This took a few tries, but I wound up finding two very similar ways of accomplishing this goal.

```
vi models.py   ## Add functions to count all, subscribed, etc. emails
vi views.py    ## Add output of counts to index function
```

Output is still not html but rather plain, unformatted, unstyled text.

## Tutorial (4) - Forms

For now, we just want to provide a simple form for people to (un)subscribe from a list for a given site.

### Requirements

The goal is just one simple view containing a form with the following elements:

* Text block: "Thank you for subscribing to very occasional email updates from us at `[site_name]`!"
* Text input for: "Name (optional):" populated from DB; default value is blank
* Check Box: "Subscribe to emails from `[site_name]`
* Text block: "To unsubscribe, uncheck the box and press Enter"
* Button: "Update"

